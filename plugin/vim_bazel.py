''' This file serves as a vim plugin for bazel users.
    Usage:
'''
import os
import vim

BAZEL = 'bazel'
OPTIONS = frozenset(['build', 'run', 'test'])
HDR_TYPE = frozenset(['h', 'hpp'])
SRC_TYPE = frozenset(['c', 'cc', 'cpp', 'py'])


def bazel_command(option, target):
    '''Generate Bazel Command for input options '''
    return '! %s %s %s' % (BAZEL, option, target)


def source_files(path, name):
    '''Find all source files in path that starts with name'''
    src_files = {}
    for fname in os.listdir(path):
        fname_ext = fname.split('.')
        if len(fname_ext) != 2 or fname_ext[1] in HDR_TYPE:
            continue

        test_base = name + '_test'
        if fname_ext[0] == test_base:
            src_files['test'] = test_base
        elif fname_ext[0] == name:
            src_files[fname_ext[1]] = name

    return src_files


def valid_module(option, file_ext, path, file_name):
    '''This function goes into the path to judge whether the current
       module is a valid module '''

    if file_ext == "":
        print "Unable to find a valid module for %s at %s" % (file_name, path)
        return None
    if file_ext in SRC_TYPE:
        return file_name
    if file_ext in HDR_TYPE:
        # if we are in a header file, we will look into the folder to
        # find either a source or a test
        src_files = source_files(path, file_name)

        if option == "build":
            for ext in src_files:
                if ext in SRC_TYPE:
                    return src_files[ext]

        if 'test' in src_files:
            return src_files['test']

    print "Cannot find a valid source to build/run for %s under option %s." \
        % (file_name, option)
    return None


def parse_buffer_name(name):
    '''Parse the path of the buffer into a tuple of filetype and module name'''

    module_name = name.split('/').pop()
    path = name[:name.rfind(module_name)]
    module = module_name.split('.')

    if len(module) != 2:
        print "Your current filename %s is not recognized." % module_name
        return -1

    return (module[1], path, module[0])


def run_bazel(option, module):
    '''Run Bazel command generated by the above function '''
    try:
        # Clear the screen before running bazel.
        vim.command("silent !clear")
        vim.command(bazel_command(option, module))
    except vim.error:
        print "VIM Failed when executing your command."
        return -1

    if vim.eval('v:shell_error') != '0':
        print "Failed"
        return -1

    print "Success"
    return 0


def Run(option):
    '''The entry method to the whole plugin '''
    if option not in OPTIONS:
        return -1

    buf_name = vim.current.buffer.name
    file_type, path, mod_name = parse_buffer_name(buf_name)

    corrected_mod_name = valid_module(option, file_type, path, mod_name)
    if corrected_mod_name is None:
        return -1

    return run_bazel(option, corrected_mod_name)
